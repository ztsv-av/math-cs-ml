# Use Case Diagrams

An analyst can employ use cases to better understand the functionality of the system at a very high level. Typically, a use‐case diagram provides a simple, straightforward way of communicating to the users exactly what the system will do. Consequently, a use‐case diagram is drawn when gathering and defining requirements of the system and can encourage the users to provide additional high‐level requirements. A use‐case diagram illustrates in a very simple way the main functions of the system and the different kinds of users that will interact with it.

Use cases are the primary drivers for all the UML diagramming techniques. A use case communicates at a high level what the system needs to do, and all the UML diagramming techniques build on this by presenting the use‐case functionality in a different way for a different purpose. Use cases are the building blocks by which the system is designed and built.

Use cases capture the typical interaction of the system with the system's users (end users and other systems). These interactions represent the external, or functional, view of the system from the perspective of the user. Each use case describes one and only one function in which users interact with the system. Although a use case may contain several paths that a user can take while interacting with the system, each possible execution path through the use case is referred to as a scenario. Another way to look at a scenario is as if a scenario is an instantiation of a specific use case. Scenarios are used extensively in behavioral modeling.

Figure 4.1
![image](https://user-images.githubusercontent.com/73081144/176576545-70c058e3-4748-4b10-b7ef-56125aafd07a.png)

![image](https://user-images.githubusercontent.com/73081144/176577280-478951b4-12b6-4786-8026-2b9f97bccfa9.png)

Figure 4.2
![image](https://user-images.githubusercontent.com/73081144/176577658-51ab47d3-c333-4ce7-841f-2b22e9ec8383.png)

## Types of Use Cases

There are many different types of use cases. We suggest two separate dimensions on which to classify a use case based on the purpose of the use case and the amount of information that the use case contains: overview versus detail and essential versus real.

- An **overview** use case is used to enable the analyst and user to agree on a high‐level overview of the requirements. Typically, overview use cases are created very early in the process of understanding the system requirements, and they document only basic information about the use case, such as its name; ID number; primary actor; type; a brief description; and the relationships among the actors, actors and use cases, and use cases. These can easily be created immediately after the creation of the use‐case diagram.

- Once the user and the analyst agree upon a high‐level overview of the requirements, the overview use cases are converted to **detail** use cases. A detail use case typically documents, as far as possible, all the information needed for the use case. These can be based on the activities and control flows contained in the activity diagrams.

- An **essential** use case is one that describes only the minimum essential issues necessary to understand the required functionality. A **real** use case goes farther and describes a specific set of steps. For example, an essential use case in a doctor office might say that the receptionist should attempt to match the patient's desired appointment times with the available times, whereas a real use case might say that the receptionist should look up the available dates on the calendar using Google Calendar to determine if the requested appointment times were available. The primary difference is that essential use cases are implementation independent, whereas real use cases are detailed descriptions of how to use the system once it is implemented. Thus, real use cases tend to be used only in the design, implementation, and testing.

## Elements of Use‐Case Diagrams

### Actors

The stick figures on the diagram represent actors (see Figure 4‐1). An actor is not a specific user but instead is a role that a user can play while interacting with the system. An actor can also represent another system in which the current system interacts. In this case, the actor optionally can be represented by a rectangle containing <<actor>> and the name of the system. Basically, actors represent the principal elements in the environment in which the system operates. Actors can provide input to the system, receive output from the system, or both. The diagram in Figure 4‐2 shows that three actors will interact with the appointment system (a patient, a doctor, and management).

Sometimes an actor plays a specialized role of a more general type of actor. For example, there may be times when a new patient interacts with the system in a way that is somewhat different from a general patient. In this case, a specialized actor (i.e., new patient) can be placed on the model, shown using a line with a hollow triangle at the end of the more general actor (i.e., patient). The specialized actor inherits the behavior of the more general actor and extends it in some way (see Figure 4‐3).

### Association

Use cases are connected to actors through association relationships; these relationships show with which use cases the actors interact (see Figure 4‐1). A line drawn from an actor to a use case depicts an association. The association typically represents two‐way communication between the use case and the actor. If the communication is only one way, then a solid arrowhead can be used to designate the direction of the flow of information. For example, in Figure 4‐2 the Patient actor communicates with the Manage Appointments use case. Because there are no arrowheads on the association, the communication is two‐way. Finally, it is possible to represent the multiplicity of the association. Figure 4‐2 shows an asterisk (*) at either end of the association between the Patient and the Manage Appointments use case. This simply indicates that an individual patient (instance of the Patient actor) executes the Manage Appointments use case as many times as he or she wishes and that it is possible for the appointment part of the Manage Appointments use case to be executed by many different patients. In most cases, this type of many‐to‐many relationship is appropriate. However, it is possible to restrict the number of patients who can be associated with the Manage Appointments use case. We discuss the multiplicity issue in detail in the next chapter in regard to class diagrams.

### Use Case

A use case, depicted by an oval in the UML, is a major process that the system performs and that benefits an actor or actors in some way (see Figure 4‐1); it is labeled using a descriptive verb–noun phrase. We can tell from Figure 4‐2 that the system has three primary use cases: Manage Appointments, Produce Schedules, and Record Availability.

There are times when a use case includes, extends, or generalizes the functionality of another use case in the diagram. These are shown using include, extend, and generalization relationships. To increase the ease of understanding a use‐case diagram, higher‐level use cases are normally drawn above the lower‐level ones. It may be easier to understand these relationships with the help of examples. Let's assume that every time a patient makes an appointment, the patient is asked to verify payment arrangements. However, it is occasionally necessary to actually make new payment arrangements. Therefore, we may want to have a use case called Make Payment Arrangements that extends the Manage Appointments use case to include this additional functionality. That is, the Manage Appointments optionally can call or execute the Make Payment Arrangements use case. In Figure 4‐4, an arrow labeled with extend was drawn from the Make Payment Arrangements use case to the Manage Appointments use case to denote this special use‐case relationship, that is, the extend relationship is drawn from the lower‐level use case to the higher level one. In this case, the Make Payment Arrangements use case was drawn lower than the Manage Appointments use case.

Similarly, there are times when a single use case contains common functions that are used by other use cases. For example, suppose there is a use case called Manage Schedule that performs some routine tasks needed to maintain the doctor's office appointment schedule, and the two use cases Record Availability and Produce Schedules both perform the routine tasks. Figure 4‐4 shows how we can design the system so that Manage Schedule is a shared use case that is used by others. An arrow labeled with include is used to denote the include relationship, and the included use case is drawn below the use cases that contain it. Notice that the arrows are drawn from the Record Availability and Produce Schedules use cases to the common Manage Schedule use case.

Finally, there are times when it makes sense to use a generalization relationship to simplify the individual use cases. For example, in Figure 4‐4, the Manage Appointments use case has been specialized to include a use case for an Old Patient and a New Patient. The Make Old Patient Appt use case inherits the functionality of the Manage Appointments use case (including the Make Payment Arrangements use‐case extension) and extends its own functionality with the Update Patient Information use case. The Make New Patient Appt use case also inherits all the functionality of the generic Manage Appointments use case and calls the Create New Patient use case, which includes the functionality necessary to create the new patient. The generalization relationship is represented as an unlabeled hollow arrow with the more general use case being higher than the lower use cases. Also, notice that we have added a second specialized actor, Old Patient, and that the Patient actor is now simply a generalization of the Old and New Patient actors.

![image](https://user-images.githubusercontent.com/73081144/176578847-fe13202d-8d4e-4d9f-b7b7-33abe54af0e1.png)

### Subject Boundary

The use cases are enclosed within a subject boundary, which is a box that defines the scope of the system and clearly delineates what parts of the diagram are external or internal to it (see Figure 4‐1). One of the more difficult decisions to make is where to draw the subject boundary. A subject boundary can be used to separate a software system from its environment, a subsystem from other subsystems within the software system, or an individual process in a software system. They also can be used to separate an information system, including both software and internal actors, from its environment.

The name of the subject can appear either inside or on top of the box. The subject boundary is drawn based on the scope of the system. In the appointment system, we assumed that the Management and Doctor actors are outside of the scope of the system; that is, they use the system. However, we could have added an internal actor (Receptionist) who captures the interaction between the patients and the respective Make Appt use cases. If we did this, we would add another boundary inside of the current boundary in which the internal actor would reside.

## Identifying the Major Use Cases

1. Review Requirements Definition
The first step is to review the requirements definition (see Figure 3‐11). This helps the analyst to get a complete overview of the underlying business process being modeled.

2. Identify Subject's Boundaries
The second step is to identify the subject's boundaries. This helps the analyst to identify the scope of the system. However, as we work through the development process, the boundary of the system most likely will change.

3. Identify Primary Actors and Goals
The third step is to identify the primary actors and their goals. The primary actors involved with the system come from a list of stakeholders and users. Recall that a stakeholder is a person, a group, or an organization that can affect (or will be affected by) a new system, whereas an actor is a role that a stakeholder or user plays, not a specific user (e.g., doctor, not Dr. Jones). The goals represent the functionality that the system must provide the actor for the system to be a success. Identifying the tasks that each actor must perform can facilitate this. For example, does the actor need to create, read, update, delete, or execute (CRUDE)6 any information currently in the system, are there any external changes of which an actor must inform the system, or is there any information that the system should give the actor? Steps 2 and 3 are intertwined. As actors are identified and their goals are uncovered, the boundary of the system will change.

4. Identify Business Processes and Major Use Cases
The fourth step is to simply identify the business processes and major use cases. Rather than jumping into one use case and describing it completely at this point, we only want to identify the major use cases. Identifying only the major use cases at this time prevents the users and analysts from forgetting key business processes and helps the users explain the overall set of business processes for which they are responsible. It is important at this point to understand and define acronyms and jargon so that the project team and others from outside the user group can clearly understand the use cases. Again, the requirements definition is a very useful beginning point for this step.

5. Review Current Set of Use Cases
The fifth step is to carefully review the current set of use cases. It may be necessary to split some of them into multiple use cases or merge some of them into a single use case. Also, based on the current set, a new use case may be identified. You should remember that identifying use cases is an iterative process, with users often changing their minds about what a use case is and what it includes. It is very easy to get trapped in the details at this point, so you need to remember that the goal at this step is to only identify the major use cases. For example, in the doctor's office example in Figure 4‐2, we defined one use case as Manage Appointments. This use case included the cases for both new patients and existing patients, as well as for when a patient changes or cancels an appointment. We could have defined each of these activities (makes an appointment, changes an appointment, or cancels an appointment) as separate use cases, but this would have created a huge set of small use cases.

The trick is to select the right size and number of use cases such that the problem domain is represented in a semantically sound manner. However, too many use cases may suggest that the use cases are too small or that the system boundary is too large, while too few use cases may imply that the size and complexity of the individual use cases are simply too large. Too large use cases will increase the complexity of the activity diagrams that we use to model the use case details (see later in this chapter). Consequently, the right number of use cases is really a function of the complexity of the problem domain. In other words, from a semantic modeling perspective, we will have to trade off the complexity of the problem domain by shifting it between the number of use cases on the use case diagram and the detailed modeling of the business process with the activity diagrams. In some situations, the use cases could be grouped together into packages (i.e., logical groups of use cases) to make the use case diagrams easier to read and to keep the activity diagrams at a reasonable level of complexity.

## Library Example

The functional requirements for an automated university library circulation system include the need to support searching, borrowing, and book‐maintenance activities. The system should support searching by title, author, keywords, and ISBN. If the book of interest is currently checked out, a valid borrower should be allowed to request the book to be returned. Once the book has been checked back in, the borrower requesting the book should be notified of the book's availability.

The borrowing activities are built around checking books out and returning books by borrowers. There are three types of borrowers: students, faculty or staff, and guests. Regardless of the type of borrower, the borrower must have a valid ID card. If the borrower is a student, the system is checked with the registrar's office to validate the ID card. If the borrower is a faculty or staff member, the system is checked with the personnel office to validate the ID card. If the borrower is a guest, the ID card is checked against the library's own system. If the ID card is valid, the system must also check to determine whether the borrower has any overdue books or unpaid fines. If the ID card is invalid, the borrower has overdue books, or the borrower has unpaid fines, the system must reject the borrower's request to check out a book, otherwise the borrower's request should be honored. If a book is checked out, the system must update the library's collection to reflect the book's new status.

The book‐maintenance activities deal with adding and removing books from the library's book collection. This requires a library manager to both logically and physically add and remove the book. Books being purchased by the library or books being returned in a damaged state typically cause these activities. If a book is determined to be damaged when it is returned and it needs to be removed from the collection, the last borrower will be assessed a fine. However, if the book can be repaired, depending on the cost of the repair, the borrower might not be assessed a fine. Every Monday, the library sends a reminder to borrowers who have overdue books. If a book is overdue more than two weeks, the borrower is assessed a fine. Depending on how long the book remains overdue, the borrower can be assessed additional fines every Monday.

To begin we need to identify the major use cases and create a use‐case diagram that represents the high‐level business processes in the business situation just described. Based on the steps to identify the major use cases, we need to review the requirements definition and identify the boundaries (scope) of the problem. Based on the description of the problem, it is obvious that the system to be created is limited to managing the library's book collection. The next thing we need to do is to identify the primary actors and business processes that need to be supported by the system. Based on the functional requirements described, the primary actors are borrowers and librarians, whereas the primary business processes are borrowing books, returning books, searching the book collection, maintaining the book collection, and processing overdue books. Now that we have identified all of the actors and major use cases, we can draw the use‐case diagram that represents an overview of the library's book collection management system (see Figure 4‐6). Notice the addition of two nonhuman actors (Personnel Office and Registrar Office).

![image](https://user-images.githubusercontent.com/73081144/176579919-4ff4be5e-1f67-42e1-bf21-be7c17759f86.png)

## Elements of a Use‐Case Description

A use‐case description contains all the information needed to build the structural (Chapter 5) and behavioral (Chapter 6) diagrams that follow, but it expresses the information in a less‐formal way that is usually simpler for users to understand. Figure 4‐13 shows a sample use‐case description.16 A use‐case description supports both overview and detail use cases.

### Overview Use Case Section

The overview use case identifies the use case and provides basic background information about the use case. This section of the use case description is associated with the use case diagram. The **use‐case name** should be a verb–noun phrase (e.g., Make Old Patient Appt). The **use‐case ID number** provides a unique way to find every use case and also enables the team to trace design decisions back to a specific requirement. The **use‐case type** is either overview or detail and essential or real. The **primary actor** is usually the trigger of the use case—the person or thing that starts the execution of the use case. The primary purpose of the use case is to meet the goal of the primary actor. The identification of the primary actor, along with the stakeholders, also provides information that will be useful in addressing role‐based access controls that support the security nonfunctional requirements covered in the design and construction chapters later in the book. The **brief description** is typically a single sentence that describes the essence of the use case.

The **importance level** can be used to prioritize the use cases. The importance level enables the users to explicitly prioritize which business functions are most important and need to be part of the first version of the system and which are less important and can wait until later versions if necessary. The importance level can use a fuzzy scale, such as high, medium, and low (e.g., in Figure 4‐13 we have assigned an importance level of high to the Make Old Patient Appt use case). It can also be done more formally using a weighted average of a set of criteria. For example, Larman17 suggests rating each use case over the following criteria using a scale from zero to five:

- The use case represents an important business process.
- The use case supports revenue generation or cost reduction.
- Technology needed to support the use case is new or risky and therefore requires considerable research.
- Functionality described in the use case is complex, risky, and/or time critical. Depending on a use case's complexity, it may be useful to consider splitting its implementation over several different versions. For example, we could include the use case point approach based on the number of transactions supported by the use case.
- The use case could increase understanding of the evolving design relative to the effort expended.

A use case may have multiple **stakeholders** that have an interest in the use case. Each use case lists each of the stakeholders with each one's interest in the use case (e.g., Old Patient and Doctor). The stakeholders' list always includes the primary actor (e.g., Old Patient).

Each use case typically has a **trigger** — the event that causes the use case to begin (e.g., Old Patient calls and asks for a new appointment or asks to cancel or change an existing appointment). A trigger can be an **external trigger**, such as a customer placing an order or the fire alarm ringing, or it can be a **temporal trigger**, such as a book being overdue at the library or the need to pay the rent.

Use‐case **relationships** explain how the use case is related to other use cases and users. There are four basic types of relationships: **association, extend, include, and generalization**. An **association relationship** documents the communication that takes place between the use case and the actors that use the use case. An actor is the UML representation for the role that a user plays in the use case. For example, in Figure 4‐13, the Make Old Patient Appt use case is associated with the actor Old Patient (see Figure 4‐4). In this case, a patient makes an appointment. All actors involved in the use case are documented with the association relationship.

An **include relationship** represents the mandatory inclusion of another use case. The include relationship enables functional decomposition—the breaking up of a complex use case into several simpler ones. For example, in Figure 4‐4, the Manage Schedule use case was considered to be complex and complete enough to be factored out as a separate use case that could be executed by the Produce Schedules and Record Availability use cases. The include relationship also enables parts of use cases to be reused by creating them as separate use cases.

An **extend relationship** represents the extension of the functionality of the use case to incorporate optional behavior. In Figure 4‐13, the Make Old Patient Appt use case conditionally uses the Update Patient Information use case. This use case is executed only if the patient's information has changed.

The **generalization relationship** allows use cases to support inheritance. For example, the use case in Figure 4‐4, the Manage Appointments use case was specialized so that a new patient would be associated with the Make New Patient Appt and an old patient could be associated with a Make Old Patient Appt. The common, or generalized, behavior of both the Make New Patient Appt and Make Old Patient Appt use cases would be placed in the generalized Manage Appointments use case. In other words, the Make New Patient Appt and Make Old Patient Appt use cases would inherit the common functionality from the Manage Appointments use case. The specialized behavior would be placed in the appropriate specialized use case. For example, the extend relationship to the Update Patient Information use case would be placed with the specialized Make Old Patient Appt use case.

### Detail Use Case Section

Finally, for detail use cases, individual steps within the business process are described. These steps are associated with the activity diagrams. Three different categories of steps, or flows of events, can be documented: normal flow of events, subflows, and alternative, or exceptional, flows:

- The **normal flow** of events includes only steps that normally are executed in a use case. The steps are listed in the order in which they are performed. In Figure 4‐13, the patient and the receptionist have a conversation regarding the patient's name, address, and action to be performed.
- In some cases, the normal flow of events should be decomposed into a set of **subflows** to keep the normal flow of events as simple as possible. In Figure 4‐13, we have identified three subflows: Create Appointment, Cancel Appointment, and Change Appointment. Each of the steps of these subflows is listed. These subflows are based on the control flow logic in the activity diagram representation of the business process (see Figure 4‐7). Alternatively, we could replace a subflow with a separate use case that could be incorporated via the include relationships (see the earlier discussion). However, this should be done only if the newly created use case makes sense by itself. For example, in Figure 4‐13, does it make sense to factor out a Create Appointment, Cancel Appointment, and/or Change Appointment use case? If it does, then the specific subflow(s) should be replaced with a call to the related use case, and the use case should be added to the include relationship list.
- **Alternative** or **exceptional flows** are ones that do happen but are not considered to be the norm. These must be documented. For example, in Figure 4‐13, we have identified two alternative or exceptional flows. The first one simply addresses the situation that occurs when the set of requested appointment time is not available. The second one is simply a second step to the alternative flow. Like the subflows, the primary purpose of separating out alternate or exceptional flows is to keep the normal flow of events as simple as possible. Again, as with the subflows, it is possible to replace the alternate or exceptional flows with separate use cases that could be integrated via the extend relationship (see the earlier discussion).

When should events be factored out from the normal flow of events into subflows? When should subflows and/or alternative or exceptional flows be factored out into separate use cases? Or when should things simply be left alone? The primary criteria should be based on the level of complexity that the use case entails. The more difficult it is to understand the use case, the more likely events should be factored out into subflows, or subflows and/or alternative or exceptional flows should be factored out into separate use cases that are called by the current use case. This, of course, creates more use cases. Therefore, the use‐case diagram will become more cluttered. In other words, the choice that the analyst must make is to have a more complex use‐case diagram with simpler use cases or have a simpler use‐case diagram with more complex use cases. Practically speaking, we must decide which makes more sense. This varies greatly, depending on the problem and the client. Remember, we are trying to represent, in a manner as complete and concise as possible, our understanding of the business processes that we are investigating so that the client can validate the requirements that we are modeling. Therefore, there really is no single right answer. It really depends on the analyst, the client, and the problem.

### Optional Characteristics

Other characteristics of use cases can be documented by use‐case descriptions. These include the level of complexity of the use case; the estimated amount of time it takes to execute the use case; the system with which the use case is associated; specific data flows between the primary actor and the use case; any specific attribute, constraint, or operation associated with the use case; any preconditions that must be satisfied for the use case to execute; or any guarantees that can be made based on the execution of the use case. As we noted at the beginning of this section, there is no standard set of characteristics of a use case that must be captured. We suggest that the information contained in Figure 4‐13 is the minimal amount to be captured.

![image](https://user-images.githubusercontent.com/73081144/176582575-9a45b3e8-368f-431a-b35d-adaaa2f5a1dd.png)

## Guidelines for Creating Use‐Case Descriptions

The essence of a use case is the flow of events. Writing the flow of events in a manner that is useful for later stages of development generally comes with experience.

First, write each individual step in the form subject–verb–direct object and, optionally, preposition–indirect object. This form is relatively easy to diagram (see sentence diagramming in Chapter 3) and has become known as SVDPI sentences. This form of sentence has proved to be useful in identifying classes and operations (see Chapter 5). For example, in Figure 4‐13, the first step in the normal flow of events, the Patient contacts the office regarding an appointment, suggests the possibility of three classes of objects: Patient, Office, and Appointment. This approach simplifies the process of identifying the classes in the structural model (see Chapter 5). SVDPI sentences cannot be used for all steps, but they should be used whenever possible.

Second, make clear who or what is the initiator of the action and who or what is the receiver of the action in each step. Normally, the initiator should be the subject of the sentence and the receiver should be the direct object of the sentence. For example, in Figure 4‐13, the second step, Patient provides the Receptionist with his or her name and address, clearly portrays the Patient as the initiator and the Receptionist as the receiver.

Third, write the step from the perspective of an independent observer. To accomplish this, each step might have to be written first from the perspective of both the initiator and the receiver. Based on the two points of view, the bird's‐eye view version can then be written. For example, in Figure 4‐13, the Patient provides the Receptionist with his or her name and address, neither the patient's nor the receptionist's perspective is represented.

Fourth, write each step at the same level of abstraction. Each step should make about the same amount of progress toward completing the use case as each of the other steps. In high‐level use cases, the amount of progress could be very substantial, whereas in a low‐level use case, each step could represent only incremental progress.

Fifth, ensure that the use case contains a sensible set of actions. Each use case should represent a transaction. Therefore, each use case should comprise four parts:

The primary actor initiates the execution of the use case by sending a request (and possibly data) to the system.
The system ensures that the request (and data) is valid.
The system processes the request (and data) and possibly changes its own internal state.
The system sends the primary actor the result of the processing.
For example, in Figure 4‐13, the patient requests an appointment (steps 1 and 2), the receptionist determines whether any of the patient's information has changed or not (step 3), the receptionist determines whether the patient's payment arrangements have changed or not (step 4), the receptionist sets up the appointment transaction (step 5), and the receptionist provides the results of the transaction to the patient (step 6).

The sixth guideline is the KISS principle. If the use case becomes too complex and/or too long, the use case should be decomposed into a set of use cases. Furthermore, if the normal flow of events of the use case becomes too complex, subflows should be used. For example, in Figure 4‐13, the fifth step in the normal flow of events was sufficiently complex to decompose it into three separate subflows. However, care must be taken to avoid the possibility of decomposing too much. Most decomposition should be done with classes (see Chapter 5).

The seventh guideline deals with repeating steps. Normally, in a programming language, we put loop definition and controls at the beginning of the loop. However, because the use‐case steps are written in simple English, it is normally better to simply write Repeat steps A through E until some condition is met after step E. It makes the use case more readable to people unfamiliar with programming.

## Creating Use Case Descriptions

Use cases provide a bird's‐eye view of the business processes contained in the evolving system. The use‐case diagram depicts the communication path between the actors and the system, while the activity diagram portrays the underlying logic structure of the use case. Use case description documentation tend to be used to model both the contexts of the system and the detailed requirements of the system. Even though the primary purpose of use cases is to document the functional requirements of the system, they also are used as a basis for testing the evolving system and as a foundation of the user interface design. In this section, we provide a set of steps that can be used to guide the actual creation of a use‐case description for each use case in the use‐case diagram based on the requirements definition and the use‐case and activity diagrams.19 These steps are performed in order, but of course the analyst often cycles among them in an iterative fashion as he or she moves from one use case to another use case.

1. Choose a Use Case
The first step is to choose one of the use cases to document with a use‐case description. Using the importance level of the use case can help do this. For example, in Figure 4‐13, the Make Old Patient Appt use case has an importance level of high. As such, it should be one of the earlier use cases to be expanded. The criteria suggested by Larman20 can also be used to set the prioritization of the use cases, as noted earlier. An alternative approach suggests that each use case should be voted on by each member of the development team. In this approach, each team member is given a set of “dots” that they can use to vote on the use cases. They can use all of their dots to vote for a single use case, or they can spread them over a set of use cases. The use cases then can be ranked in order of the number of dots received. Use case descriptions are created for the individual use cases based on the rank order.

2. Create Overview Description
The second step is to create an overview description of the use case; that is, name the primary actor, set the type for the use case, list all of the identified stakeholders and their interests in the use case, identify the level of importance of the use case, give a brief description of the use case, give the trigger information for the use case, and list the relationships in which the use case participates. This can be done immediately after the use case diagram has been created.

3. Describe the Normal Flow of Events
The third step is to fill in the steps of the normal flow of events required to describe each use case. The steps focus on what the business process does to complete the use case, as opposed to what actions the users or other external entities do. In general, the steps should be listed in the order in which they are performed, from first to last. Remember to write the steps in an SVDPI form whenever possible. In writing the use case, remember the seven guidelines described earlier. The goal at this point is to describe how the chosen use case operates. One of the best ways to begin to understand how an actor works through a use case is to visualize performing the steps in the use case—that is, role play. The techniques of visualizing how to interact with the system and of thinking about how other systems work (informal benchmarking) are important techniques that help analysts and users understand how systems work and how to write a use case. Both techniques (visualization and informal benchmarking) are common in practice. It is important to remember that at this point in the development of a use case, we are interested only in the typical successful execution of the use case. If we try to think of all of the possible combinations of activities that could go on, we will never get anything written. At this point, we are looking only for the three to seven major steps. Focus only on performing the typical process that the use case represents. If the activity diagram has been completed, then the activities will serve as a basis for the events. Furthermore, the most likely path through the activity diagram should be the basis for the normal flow of events.

4. Check the Normal Flow of Events
The fourth step is to ensure that the steps listed in the normal flow of events are not too complex or too long. Each step should be about the same size as the others. For example, if we were writing steps for preparing a meal, steps such as take fork out of drawer and put fork on table are much smaller than prepare cake using mix. If we end up with more than seven steps or steps that vary greatly in size, we should go back and review each step carefully and possibly rewrite the steps.
One good approach to produce the steps for a use case is to have the users visualize themselves actually performing the use case and to have them write down the steps as if they were writing a recipe for a cookbook. In most cases, the users will be able to quickly define what they do in the as‐is model. Defining the steps for to‐be use cases might take a bit more coaching. In our experience, the descriptions of the steps change greatly as users work through a use case. Our advice is to use a blackboard or whiteboard (or paper with pencil) that can be easily erased to develop the list of steps and then write the list on the use‐case form. It should be written on the use‐case form only after the set of steps is fairly well defined. As stated above, these steps should be associated with the activities in the activity diagram.

5. Identify Alternative or Exceptional Flows
The fifth step focuses on identifying and writing the alternative or exceptional flows. Alternative or exceptional flows are flows of success that represent optional or exceptional behavior. They tend to occur infrequently or as a result of a normal flow failure. They should be labeled so that there is no doubt as to which normal flow of events it is related. For example, in Figure 4‐13, alternative/exceptional flow S‐1, 2a1 executes when step 2 of subflow S‐1 fails (i.e., the requested appointment time was not available). Like the normal flows and subflows, alternative or exceptional flows should be written in the SVDPI form whenever possible.

6. Review the Use‐Case Description
The sixth step is to carefully review the use‐case description and confirm that the use case is correct as written, which means reviewing the use case with the users to make sure each step is correct. The review should look for opportunities to simplify a use case by decomposing it into a set of smaller use cases, merging it with others, looking for common aspects in both the semantics and syntax of the use cases, and identifying new use cases. This is also the time to look into adding the include, extend, and/or generalization relationships between use cases. The most powerful way to confirm a use case is to ask the user to role‐play, or execute the process using the written steps in the use case.22 The analyst hands the user pieces of paper labeled with the major inputs to the use case and has the user follow the written steps like a recipe to make sure that those steps really can produce the outputs defined for the use case using its inputs.

7. Repeat Until Done
The seventh and final step is to iterate the entire set of steps again. Users often change their minds about what is a use case and what it includes. It is very easy to get trapped in the details at this point, so remember that the goal is to just address the major use cases. Therefore, the analyst should continue to iterate these steps until he or she and the users believe that a sufficient number of use cases have been documented to begin identifying candidate classes for the structural model (see Chapter 5). As candidate classes are identified, it is likely that additional use cases will be uncovered.
