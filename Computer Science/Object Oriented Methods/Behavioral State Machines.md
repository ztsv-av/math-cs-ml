# Behavioral State Machines

Some of the classes in the class diagrams represent a set of objects that are quite dynamic in that they pass through a variety of states over the course of their existence. For example, a patient can change over time from being new to current to former based on his or her status with the doctor's office. A behavioral state machine is a dynamic model that shows the different states through which a single object passes during its life in response to events, along with its responses and actions. Typically, *behavioral state machines* are not used for all objects; rather, behavioral state machines are used with complex objects to further define them and to help simplify the design of algorithms for their methods. The behavioral state machine shows the different states of the object and what events cause the object to change from one state to another. Behavioral state machines should be used to help understand the dynamic aspects of a single class and how its instances evolve over time11 unlike interaction diagrams that show how a particular use case or use‐case scenario is executed over a set of classes.

## States, Events, Transitions, Actions, and Activities

The *state* of an object is defined by the value of its attributes and its relationships with other objects at a particular point in time. For example, a patient might have a state of new, current, or former. The attributes or properties of an object affect the state that it is in, however, not all attributes or attribute changes will make a difference. For example, think about a patient's address. Those attributes make very little difference to changes in a patient's state. However, if states were based on a patient's geographic location (e.g., in‐town patients were treated differently than out‐of‐town patients), changes to the patient's address would influence state changes.

An *event* is something that takes place at a certain point in time and changes a value or values that describe an object, which, in turn, changes the object's state. It can be a designated condition becoming true, the receipt of the call for a method by an object, or the passage of a designated period of time. The state of the object determines exactly what the response will be.

A *transition* is a relationship that represents the movement of an object from one state to another state. Some transitions have a guard condition. A *guard condition* is a Boolean expression that includes attribute values, which allows a transition to occur only if the condition is true. An object typically moves from one state to another based on the outcome of an action triggered by an event. All transitions are associated with an event that must be implemented as an operation with the object's class. Consequently, if there is a transition in a behavioral state machine that is not associated with an operation, then either the transition is in error or an operation is missing.

## Elements of a Behavioral State Machine

Figure 6‐20 presents an example of a behavioral state machine representing the patient class in the context of a hospital environment. From this diagram, we can tell that a patient enters a hospital and is admitted after checking in. If a doctor finds the patient to be healthy, he or she is released and is no longer considered a patient after two weeks elapse. If a patient is found to be unhealthy, he or she remains under observation until the diagnosis changes.

![image](https://user-images.githubusercontent.com/73081144/179663717-857891a4-82a0-457b-acb7-43f6cb9fea7b.png)

A state is a set of values that describes an object at a specific point in time and represents a point in an object's life in which it satisfies some condition, performs some action, or waits for something to happen (see Figure 6‐21). In Figure 6‐20 states include entering, admitted, released, and under observation. A state is depicted by a state symbol, which is a rectangle with rounded corners with a descriptive label that communicates a particular state. There are two exceptions. An initial state is shown using a small, filled‐in circle, and an object's final state is shown as a circle surrounding a small, filled‐in circle. These exceptions depict when an object is created and when an object is deleted, respectively.

Arrows are used to connect the state symbols, representing the transitions between states. Each arrow is labeled with the appropriate event name and any parameters or conditions that may apply. For example, the two transitions from admitted to released and under observation contain guard conditions. As in the other behavioral diagrams, in many cases it is useful to explicitly show the context of the behavioral state machine using a frame.

![image](https://user-images.githubusercontent.com/73081144/179663902-a184042c-3159-49ab-8336-a11fabfecda8.png)

## Additional Examples

![image](https://user-images.githubusercontent.com/73081144/179664139-6b45c0fc-d79b-4104-a7f2-6ae6c2742110.png)

Sometimes, states and subclasses can be confused. For example, in Figure 6‐23, are the classes Freshman, Sophomore, Junior, and Senior subclasses of the class Undergraduate or are they states that an instance of the Undergraduate class goes through during its lifetime? In this case, the latter is the better answer. When trying to identify all potential classes during structural modeling (see Chapter 5), you might actually identify states of the relevant superclass instead of subclasses. This is another example of how tightly intertwined the functional, structural, and behavioral models can be. From a modeling perspective, although we eventually removed the Freshman, Sophomore, Junior, and Senior subclasses from the structural model, capturing that information during structural modeling and removing it based on discoveries made during behavioral modeling were preferable to omitting it and taking a chance of missing a crucial piece of information about the problem domain. Remember, object‐oriented development is iterative and incremental. As we progress to a correct model of the problem domain, we will make many mistakes.

![image](https://user-images.githubusercontent.com/73081144/179664308-9f25e0af-1e9d-4562-a2a2-828ac14c1f42.png)

## Guidelines for Creating Behavioral State Machines

- Create a behavioral state machine for objects whose behavior changes based on the state of the object. In other words, do not create a behavioral state machine for an object whose behavior is always the same regardless of its state. These objects are too simple.
- To adhere to the left‐to‐right and top‐to‐bottom reading conventions of Western cultures, the initial state should be drawn in the top left corner of the diagram and the final state should be drawn in the bottom right of the diagram.
- Make sure that the names of the states are simple, intuitively obvious, and descriptive. For example, in Figure 6‐20, the state names of the Patient object are Entering, Admitted, Under Observation, and Released.
- Question black hole and miracle states. These types of states are problematic for the same reason black hole and miracle activities are a problem for activity diagrams (see Chapter 4). Black hole states, states that an object goes into and never comes out of, most likely are actually final states. Miracle states, states that an object comes out of but never went into, most likely are initial states.
- Be sure that all guard conditions are mutually exclusive (not overlapping). For example, in Figure 6‐20, the guard condition [Diagnosis = Healthy] and the guard condition [Diagnosis = Unhealthy] do not overlap. However, if you created a guard condition of [x >= 0] and a second guard condition [x <= 0], the guard conditions overlap when x = 0, and it is not clear to which state the object would transition. This would obviously cause confusion.
- All transitions should be associated with a message and an operation. Otherwise, the state of the object could never change. Even though this may be stating the obvious, there have been numerous times that analysts forget to go back and ensure that this is indeed true.

## Creating a Behavioral State Machine

1. Set Context
Behavioral state machines are drawn to depict an instance of a single class from a class diagram. Typically, the classes are very dynamic and complex, requiring a good understanding of their states over time and events triggering changes. You should examine your class diagram to identify which classes undergo a complex series of state changes and draw a diagram for each of them. In this section, we describe a five‐step process used to build a behavioral state machine.13 Like the other behavioral models, the first step in the process is determining the context of the behavioral state machine, which is shown in the label of the frame of the diagram. The context of a behavioral state machine is usually a class. However, it also could be a set of classes, a subsystem, or an entire system.
2. Identify Object States
The second step is to identify the various states that an object will have over its lifetime. This includes establishing the boundaries of the existence of an object by identifying the initial and final states of an object. The information necessary to perform this is gleaned from reading the use‐case descriptions, talking with users, and relying on the requirements‐gathering techniques that you learned about in Chapter 3. An easy way to identify the states of an object is to write the steps of what happens to an object over time, from start to finish, similar to how the normal flow of events section of a use‐case description would be created.
3. Lay Out Diagram
The third step is to determine the sequence of the states that an object will pass through during its lifetime. Using this sequence, the states are placed onto the behavioral state machine in a left‐to‐right order.
4. Add Transitions
The fourth step is to identify the transitions between the states of the objects and to add the events, actions, and guard conditions associated with the transitions. The events are the triggers that cause an object to move from one state to the next state. In other words, an event causes an action to execute that changes the value(s) of an object's attribute(s) in a significant manner. The actions are typically operations contained within the object. Also, guard conditions can model a set of test conditions that must be met for the transition to occur. At this point in the process, the transitions are drawn between the relevant states and labeled with the event, action, or guard condition.
5. Validate
The fifth step is to validate the behavioral state machine by making sure that each state is reachable and that it is possible to leave all states except for final states. Obviously, if an identified state is not reachable, either a transition is missing or the state was identified in error. Only final states can be a dead end from the perspective of an object's life cycle.

## Library Example

The first step in drawing a behavioral state machine is to set the context. For our purposes, the context typically is an instance of a class that has multiple states and whose behavior depends upon the state in which it currently resides. As suggested earlier, we should review the class diagram (see Figure 6‐25) to identify the “interesting” classes. In the case of the Library Book Collection Management System, the obvious class to consider is the Book class.

The next step is to identify the different states through which an instance of the Book class can traverse during its lifetime. Good places to look for possible state changes are the use‐case descriptions (see Figure 6‐12), the activity diagrams (see Figure 6‐13), and the sequence diagrams (see Figure 6‐15). In the case of a book, even though the states may be similar, you must be careful in identifying the states associated with an instance of the Book class and not the states associated with the physical book itself. In Chapter 5, we observed that there were a number of implied states to consider. These included Checked Out, Overdue, Requested, Available, and Damaged. If the book is damaged, the book could either be repaired and put back into circulation or it could be too damaged to repair and be removed from circulation instead. Even though a Borrower could be fined for an overdue or damaged book, being fined is not a state of a book, it is a state of a borrower.

Next, we lay out the diagram by ordering the states in a sequential manner based on the life cycle of a book. For example, it probably makes no sense to have a book to go from a repaired state to a damaged state. However, going from a damaged state to a repaired state makes sense. Nor does it make sense for a book to go from an available state directly to an overdue state. However, the converse makes sense. The states we identified for a book object include Available, Checked Out, Overdue, Requested, Damaged, and Being Repaired. Next, we added the transitions between the states and labeled them with the appropriate guard conditions. The behavioral state machine for an instance of the Book class is portrayed in Figure 6‐26.

![image](https://user-images.githubusercontent.com/73081144/179664960-cbe2b380-32e5-46e6-baef-9281c1d17758.png)
