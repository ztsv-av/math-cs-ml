# Sequence Diagram

A sequence diagram is a dynamic model that shows the explicit sequence of messages that are passed between objects in a defined interaction.

The sequence diagram can be a *generic sequence diagram* that shows all possible scenarios1 for a use case, but usually each analyst develops a set of *instance sequence diagrams*, each of which depicts a single use case scenario within the use case. The diagrams are used throughout the analysis and design phases. However, the design diagrams are very implementation specific, often including database objects or specific user interface components as the objects.

## Sequence Diagram Example

![image](https://user-images.githubusercontent.com/73081144/178654701-9b1dab95-e275-46eb-b70e-42440b31e9eb.png)

Sequence diagram that depicts the objects and messages for the Make Old Patient Appt use case, which describes the process by which an existing patient creates a new appointment or cancels or reschedules an appointment for the doctor's office appointment system. In this specific instance, the Make Old Patient Appt process only portrays the successful scenario of creating an appointment.

## Elements of a Sequence Diagram

*Actors* and *objects* that participate in the sequence are placed across the top of the diagram using actor symbols and object symbols (see Figure 6‐2). Notice that the actors and objects in Figure 6‐5 are aPatient, aReceptionist, aPatient, UnpaidBill, and Appointment.2 For each of the objects, the name of the class of which they are an instance is given after the object's name (e.g., aPatient means that aPatient is an instance of the Patient class).

A dotted line runs vertically below each actor and object to denote the *lifeline* of the actors and objects over time (see Figure 6‐5).3 Sometimes an object creates a *temporary object*; in this case, an X is placed at the end of the lifeline at the point where the object is destroyed (not shown). For example, think about a shopping cart object for a Web commerce application. The shopping cart is used for temporarily capturing line items for an order, but once the order is confirmed, the shopping cart is no longer needed. In this case, an X would be located at the point at which the shopping cart object is destroyed. When objects continue to exist in the system after they are used in the sequence diagram, then the lifeline continues to the bottom of the diagram (this is the case with all of the objects in Figure 6‐5).

A thin rectangular box, called the *execution occurrence*, is overlaid onto the lifeline to show when the classes are sending and receiving messages (see Figure 6‐6). A message is a communication between objects that conveys information with the expectation that activity will ensue. Many different types of messages can be portrayed on a sequence diagram. However, in the case of using sequence diagrams to model use cases, two types of messages are typically used: operation call and return. *Operation call messages* passed between objects are shown using solid lines connecting two objects with an arrow on the line showing which way the message is being passed. Argument values for the message are placed in parentheses next to the message's name. The order of messages goes from the top to the bottom of the page, so messages located higher on the diagram represent messages that occur earlier on in the sequence, versus the lower messages that occur later. A *return message* is depicted as a dashed line with an arrow on the end of the line portraying the direction of the return. The information being returned is used to label the arrow. However, because adding return messages tends to clutter the diagram, unless the return messages add a lot of information to the diagram, they can be omitted. For example, in Figure 6‐5, no return messages are depicted.4 In Figure 6‐5, LookUpPatient() is a message sent from the actor aReceptionist to the object aPatient to determine whether the aPatient actor is a current patient.

![image](https://user-images.githubusercontent.com/73081144/178655396-72c8491e-f5bd-416c-b01c-dc89296192b9.png)

At times a message is sent only if a condition is met. In those cases, the condition is placed between a set of brackets, [ ]—for example, [aPatient Exists] LookupBills(). The condition is placed in front of the message name. However, when using a sequence diagram to model a specific scenario, conditions are typically not shown on any single sequence diagram. Instead, conditions are implied only through the existence of different sequence diagrams.

An object can send a message to itself, e.g., Create Sandwich in Figure 6‐7. This is known as self‐delegation. Sometimes, an object creates another object. This is shown by the message being sent directly to an object instead of its lifeline.

Figure 6‐7 portrays two additional examples of instance‐specific sequence diagrams. The first one is related to the Make Lunch use case that was described in the activity diagram portrayed in Figure 4‐10. The second one is related to the Place Order use case associated with the activity diagram in Figure 4‐9. In both examples, the diagrams simply represent a single scenario. Notice that in the Make Lunch sequence diagram there is a message being sent from an actor to itself [CreateSandwich()]. Depending on the complexity of the scenario being modeled, this particular message could have been eliminated. Obviously, both the process of making a lunch and placing an order can be quite a bit more complex. However, from a learning point of view, you should be able to see how the sequence diagrams and the activity diagrams relate to one another.

![image](https://user-images.githubusercontent.com/73081144/178655737-f8a2d17d-ada6-44f7-87eb-29244dbffc0c.png)

Some use cases call other use cases using the extend and include relationship types. In those cases, we need to show the call to the other use case in the related sequence diagram. For example, the Make New Patient Appt use case (Figure 4‐21) calls or executes the Make Payment Arrangements and the Create New Patient use cases via the include relationship that points from the parent use case to the two child use cases. To portray this correctly in a sequence diagram requires us to use the frame symbol for each of the two child use cases and to send an execute message to the frame. In Figure 6‐8, aReceptionist actor sends the Execute message to each of the two child use cases.

![image](https://user-images.githubusercontent.com/73081144/178655975-1d64828d-dc12-4527-8bb5-fa0ca4b313cd.png)

Some use cases contain iterative processes in which a loop should be modeled. For example, Figure 6‐9 portrays a sequence diagram that portrays the process that a course registration system might need to model. In this case, the student makes a set of course requests to a registration manager that iterates over a set of classes that are available to enable the student to add courses to their course request. Again, like the previous sequence diagram this is an instant‐specific diagram that only portrays the situation in which the courses are available. Notice that the frame not only includes the loop label, but it also includes the condition that terminates the loop: while more courses to request. Other versions of this diagram would be required to portray the situation when a course is not available. For example, the student request could be put onto a waiting list for the courses that were not currently available.

![image](https://user-images.githubusercontent.com/73081144/178656099-698db8ac-1a0f-456f-9933-6b469261155f.png)

## Guidelines for Creating Sequence Diagrams

- Try to have the messages not only in a top‐to‐bottom order but also, when possible, in a left‐to‐right order. Given that Western cultures tend to read left to right and top to bottom, a sequence diagram is much easier to interpret if the messages are ordered as much as possible in the same way. To accomplish this, order the actors and objects along the top of the diagram in the order that they participate in the scenario of the use case.
- If an actor and an object conceptually represent the same idea, one inside of the software and the other outside, label them with the same name. In fact, this implies that they exist in both the use‐case diagram (as an actor) and in the class diagram (as a class). At first glance, this might seem to lead to confusion. However, if they do indeed represent the same idea, then they should have the same name. For example, a customer actor interacts with the system and the system stores information about the customer. In this case, they do indeed represent the same conceptual idea.
- The initiator of the scenario—actor or object—should be the drawn as the farthest left item in the diagram. This guideline is essentially a specialization of the first guideline. In this case, it relates specifically to the actor or object that triggers the scenario.
- When there are multiple objects of the same type, be sure to include a name for the object in addition to the class of the object. For example, in the making a lunch example (see Figure 6‐7) there are two objects of type Parent. As such, they should be named. Otherwise, you can simply use the class name. This will simplify the diagram. In this case, the Child object did not have to be named. We could have simply placed a colon in front of the class name instead.
- Show return values only when they are not obvious. Showing all of the returns tends to make a sequence diagram more complex and potentially difficult to comprehend. In many cases, less is more. Only show the returns that actually add information for the reader of the diagram.
- Justify message names and return values near the arrowhead of the message and return arrows, respectively. This makes it much easier to interpret the messages and their return values.

## Creating a Sequence Diagram
1. Set Context
The first step in the process is to determine the context of the sequence diagram. The context of the diagram can be a system, a use case, or a scenario of a use case. The context of the diagram is depicted as a labeled frame around the diagram (see Figures 6‐5–6‐9). Most commonly, it is one use‐case scenario. Figure 6‐5 portrays the instance sequence diagram for the scenario from the Make Old Patient Appt use case description given in Figure 4‐13 for making a new appointment for an existing patient. For each possible scenario for the Make Old Patient Appt use case, a separate instance sequence diagram would be created. On the surface, this seems to be a lot of potentially redundant and useless work. However, at this point in the representation of a system, we are still trying to completely understand the problem. This process of creating instance sequence diagrams for each scenario instead of creating a single generic sequence diagram for the entire use case will enable the developers to attain a more complete understanding of the problem being addressed. For example, the instance sequence diagram in Figure 6‐5 is much simpler than the activity diagram in Figure 6‐4. Each instance sequence diagram is fairly simple to interpret, whereas a generic sequence diagram can be very complex. The testing of a specific use case is accomplished in a much easier manner by validating and verifying the completeness of the set of instance sequence diagrams instead of trying to work through a single complex generic sequence diagram.
2. Identify Actors and Objects
The second step is to identify the actors and objects that participate in the sequence being modeled, i.e., the actors and objects that interact with each other during the use‐case scenario. The actors were identified during the creation of the functional model, whereas the objects are identified during the development of the structural model. These are the classes on which the objects of the sequence diagram for this scenario will be based. One very useful approach to identifying all of the scenarios associated with a use case is to role‐play the CRC cards (see Chapter 5). This can help you identify potentially missing operations that are necessary to support the business process, which the use case is representing, in a complete manner. Also, during role‐playing, it is likely that new classes, and hence new objects, will be uncovered.7 Don't worry too much about identifying all the objects perfectly; remember that the behavioral modeling process is iterative. Usually, the sequence diagrams are revised multiple times during the behavioral modeling processes.
3. Set Lifeline
The third step is to set the lifeline for each object. To do this, you need to draw a vertical dotted line below each class to represent the class's existence during the sequence. An X should be placed below the object at the point on the lifeline where the object goes out of existence.
4. Add Messages
The fourth step is to add the messages to the diagram. This is done by drawing arrows to represent the messages being passed from object to object, with the arrow pointing in the message's transmission direction. The arrows should be placed in order from the first message (at the top) to the last (at the bottom) to show time sequence. Any parameters passed along with the messages should be placed in parentheses next to the message's name. If a message is expected to be returned as a response to a message, then the return message is not explicitly shown on the diagram.
5. Place Execution Occurrence
The fifth step is to place the execution occurrence on each object's lifeline by drawing a narrow rectangle box over the lifelines to represent when the classes are sending and receiving messages.
6. Validate
The sixth and final step is to validate the sequence diagram. The purpose of this step is to guarantee that the sequence diagram completely represents the underlying process. This is done by guaranteeing that the diagram depicts all the steps in the process.8
Campus Housing Example

## Library Example

When considering instance sequence diagrams, we need to draw one sequence diagram per scenario. In the case of the Borrow Books use case in Chapter 4, there are nine different scenarios. Therefore, for this one use case, there would be nine separate instance sequence diagrams. In this example, we are setting the context of the sequence diagram to only one specific scenario of the Borrow Books use case: Students who have a valid ID and do not have any overdue books or any fines. The other scenarios include Students without a valid ID, Students with a valid ID but who owe fines or have overdue books, and the same three scenarios for the other two types of Borrowers: Faculty/Staff and Guest. In this example, we are only drawing the one sequence diagram for the Students with a valid ID scenario. To begin with, we should review the Flow of Events of the use‐case description (see Figure 6‐12), the activity diagram (see Figure 6‐13), and the use‐case diagram (see Figure 6‐14).

The next step is to identify the actors and objects involved in the scenario. By studying the flow of events and the use‐case diagram, we identify students, librarians, and the registrar's office as actors and borrowers, the book collection, and books as the objects. We place the actors and objects across the top of the diagram based on the ordering of their appearance in the normal flow of events. The next step involves simply drawing the lifelines beneath the actors and objects in the scenario. The fourth step is to add the actual messages to the diagram. To do this, we again review the actual steps taken when executing this scenario by reviewing the flow of events (see Figure 6‐12) and the activity diagram (see Figure 6‐13). We also should review any results from the role‐playing of the CRC cards (see Chapter 5). This will help us to properly portray where the functionality is located. For example, in Figure 6‐12, the Librarian executes the CheckOutBooks() procedure (the Student sends the message CheckOutBooks () to ask the Librarian to execute the CheckOutBooks () procedure) when the student hands the librarian the books to check out. The Librarian in return asks the Student for the ID card. When the student hands the ID Card to the Librarian, the Librarian asks the Registrar's Office to execute the ValidID() procedure when the Librarian passes the student's ID number over to the Registrar Office system to validate the student's ID number. This continues until the ID Card and Books are returned to the student. Once we have 

![image](https://user-images.githubusercontent.com/73081144/178657974-65b9ce46-89ba-4711-9b01-774a1ef1a22d.png)

![image](https://user-images.githubusercontent.com/73081144/178657992-a159f29c-7f7b-4656-99aa-9e3fccbf5470.png)

![image](https://user-images.githubusercontent.com/73081144/178658012-821e54fe-a171-4403-a8a2-4494b4009e3a.png)

![image](https://user-images.githubusercontent.com/73081144/178658029-0e7c7d3a-f7cc-4350-874e-3b9820b7ce80.png)

![image](https://user-images.githubusercontent.com/73081144/178657700-3ea38db7-5b96-42d1-b64e-7d62d0ff62cd.png)
