## Class Diagram

A class diagram is a static model that shows the classes and the relationships among classes that remain constant in the system over time. The class diagram depicts classes, which include both behaviors and states, with the relationships between the classes. The following sections present the elements of the class diagram, different approaches that can be used to simplify a class diagram, and an alternative structure diagram: the object diagram.

![image](https://user-images.githubusercontent.com/73081144/177243114-63471c13-acac-4a42-a8a3-46cd5dd202f4.png)

## Elements of a Class Diagram

![image](https://user-images.githubusercontent.com/73081144/177243197-6efc4776-0fa9-4889-8dfb-4a22e55851e8.png)

### Class

The main building block of a class diagram is the class, which stores and manages information in the system (see Figure 5‐8). Classes support encapsulation by capturing both the attributes and operations in a single construct. During analysis, classes refer to the people, places, and things about which the system will capture information. Later, during design and implementation, classes can refer to implementation‐specific artifacts such as windows, forms, and other objects used to build the system. Each class is drawn using a three‐part rectangle, with the class name at the top, attributes in the middle, and operations at the bottom. We can see that the classes identified earlier, such as Participant, Doctor, Patient, Receptionist, Medical History, Appointment, and Symptom, are included in Figure 5‐7. The value of an object's attributes define the state of the object and the behavior of an object is represented by the operations that are defined with the object's class.

Attributes are properties of the class about which we want to capture information (see Figure 5‐8). Notice that the Participant class in Figure 5‐7 contains the attributes: lastname, firstname, address, phone, and birthdate. At times, you might want to store derived attributes, which are attributes that can be calculated or derived; these special attributes are denoted by placing a slash (/) before the attribute's name. Notice how the person class contains a derived attribute called /age, which can be derived by subtracting the patient's birth date from the current date. It is also possible to show the visibility of the attribute on the diagram. Visibility relates to the level of information hiding to be enforced for the attribute. The visibility of an attribute can be public (+), protected (#), or private (−). A public attribute is one that is not hidden from any other object. As such, other objects can modify its value. A protected attribute is one that is hidden from all other classes except its immediate subclasses. A private attribute is one that is hidden from all other classes. The default visibility for an attribute is normally private.

Operations are actions or functions that a class can perform (see Figure 5‐8). The functions that are available to all classes (e.g., create a new instance, return a value for a particular attribute, set a value for a particular attribute, delete an instance) are not explicitly shown within the class rectangle. Instead, only operations unique to the class are included, such as the cancel without notice operation in the Appointment class and the calculate last visit operation in the Patient class in Figure 5‐7. Notice that both the operations are followed by parentheses, which contain the parameter(s) needed by the operation. If an operation has no parameters, the parentheses are still shown but are empty. As with attributes, the visibility of an operation can be designated public, protected, or private. The default visibility for an operation is normally public.

There are four types of operations that all classes should contain: constructor, query, update, and destructor. A **constructor operation** creates a new instance of a class. For example, the patient class may have a method called insert (), which creates a new patient instance as patients are entered into the system. As we just mentioned, if an operation implements one of the basic functions (e.g., create a new instance), it is normally not explicitly shown on the class diagram, so typically we do not see constructor methods explicitly on the class diagram.

A **query operation** makes information about the state of an object available to other objects, but it does not alter the object in any way. For instance, the calculate last visit () operation that determines when a patient last visited the doctor's office will result in the object's being accessed by the system, but it will not make any change to its information. If a query method merely asks for information from attributes in the class (e.g., a patient's name, address, phone), then it is not shown on the diagram because we assume that all objects have operations that produce the values of their attributes.

An **update operation** changes the value of some or all the object's attributes, which may result in a change in the object's state. Consider changing the status of a patient from new to current with a method called change status() or associating a patient with a particular appointment with make appointment (appointment). If the result of the operation can change the state of the object, then the operation must be explicitly included on the class diagram. On the other hand, if the update operation is a simple assignment operation, it can be omitted from the diagram.

A **destructor operation** simply deletes or removes the object from the system. For example, if an employee object no longer represents an actual employee associated with the firm, a destructor operation would be used to delete the employee object. However, deleting an object is one of the basic functions and therefore would not be included on the class diagram.

### Relationships

A primary purpose of a class diagram is to show the relationships, or associations, that classes have with one another. These are depicted on the diagram by drawing lines between classes (see Figure 5‐8). When multiple classes share a relationship (or a class shares a relationship with itself), a line is drawn and labeled with either the name of the relationship or the roles that the classes play in the relationship. For example, in Figure 5‐7 the two classes patient and appointment are associated with one another whenever a patient schedules an appointment. Thus, a line labeled schedules connects patient and appointment, representing exactly how the two classes are related to each other. Also, notice that there is a small solid triangle beside the name of the relationship. The triangle allows a direction to be associated with the name of the relationship. In Figure 5‐7, the schedules relationship includes a triangle, indicating that the relationship is to be read as “patient schedules appointment.” Inclusion of the triangle simply increases the readability of the diagram. In Figure 5‐9, three additional examples of associations are portrayed: An Invoice is AssociatedWith a Purchase Order (and vice versa), a Pilot Flies an Aircraft, and a Spare Tire IsLocatedIn a Trunk.

Sometimes a class is related to itself, as in the case of a patient being the primary insurance carrier for other patients (e.g., spouse, children). In Figure 5‐7, notice that a line was drawn between the patient class and itself and called primary insurance carrier to depict the role that the class plays in the relationship. Notice that a plus (+) sign is placed before the label to communicate that it is a role as opposed to the name of the relationship. When labeling an association, we use either a relationship name or a role name (not both), whichever communicates a more thorough understanding of the model.

Relationships also have multiplicity, which documents how an instance of an object can be associated with other instances. Numbers are placed on the association path to denote the minimum and maximum instances that can be related through the association in the format minimum number..maximum number (see Figure 5‐10). The numbers specify the relationship from the class at the far end of the relationship line to the end with the number. For example, in Figure 5‐7, there is a 0..* on the appointment end of the patient schedules appointment relationship. This means that a patient can be associated with zero through many different appointments. At the patient end of this same relationship, there is a 1..1, meaning that an appointment must be associated with one and only one patient. In Figure 5‐9, we see that an instance of the Invoice class must be AssociatedWith one instance of the Purchase Order class and that an instance of the Purchase Order class may be AssociatedWith zero or more instances of the Invoice class, that an instance of the Pilot class Flies zero or more instances of the Aircraft class, and that an instance of the Aircraft class may be flown by zero or more instances of the Pilot class. Finally, we see that an instance the Spare Tire class IsLocatedIn zero or one instance of the Trunk class, whereas an instance of the Trunk class can contain zero or one instance of the Spare Tire class.

![image](https://user-images.githubusercontent.com/73081144/177244240-02141dfd-06b5-4be1-9bc3-50c524769fb0.png)

![image](https://user-images.githubusercontent.com/73081144/177244270-68921e98-5679-4673-a0ed-ce611c01fa31.png)

There are times when a relationship itself has associated properties, especially when its classes share a many‐to‐many relationship. In these cases, a class called an association class is formed, which has its own attributes and operations.14 It is shown as a rectangle attached by a dashed line to the association path, and the rectangle's name matches the label of the association. Think about the case of capturing information about illnesses and symptoms. An illness (e.g., the flu) can be associated with many symptoms (e.g., sore throat, fever), and a symptom (e.g., sore throat) can be associated with many illnesses (e.g., the flu, strep throat, the common cold). Figure 5‐7 shows how an association class can capture information about remedies that change depending on the various combinations. For example, a sore throat caused by strep throat requires antibiotics, whereas treatment for a sore throat from the flu or a cold could be throat lozenges or hot tea. Another way to decide when to use an association class is when attributes that belong to the intersection of the two classes involved in the association must be captured. We can visually think about an association class as a Venn diagram. For example, in Figure 5‐11, the Grade idea is really an intersection of the Student and Course classes, because a grade exists only at the intersection of these two ideas. Another example shown in Figure 5‐11 is that a job may be viewed as the intersection between a Person and a Company. Most often, classes are related through a normal association; however, there are two special cases of an association that you will see appear quite often: generalization and aggregation.

![image](https://user-images.githubusercontent.com/73081144/177244572-88e04618-f8f6-40d1-9bbe-ba8e9dd68d07.png)

### Generalization and Aggregation Associations

A **generalization association** shows that one class (subclass) inherits from another class (superclass), meaning that the properties and operations of the superclass are also valid for objects of the subclass, that is, the generalization association supports the generalization and class inclusion relationships. The generalization path is shown with a solid line from the subclass to the superclass and a hollow arrow pointing at the superclass (see Figure 5‐8). For example, Figure 5‐7 communicates that doctors, nurses, and receptionists are all kinds of employees and those employees and patients are kinds of participants. Remember that the generalization relationship occurs when you need to use words like “is a kind of” to describe the relationship. Some additional examples of generalization are given in Figure 5‐12. For example, Cardinal is a‐kind‐of Bird, which is a‐kind‐of Animal; a General Practitioner is a‐kind‐of Physician, which is a‐kind‐of Person; and a Truck is a‐kind‐of Land Vehicle, which is a‐kind‐of Vehicle.

![image](https://user-images.githubusercontent.com/73081144/177244898-65c5051e-57d0-46ba-af89-d0d66f52a64b.png)

An **aggregation association** is used when classes actually comprise other classes. The aggregation association supports the aggregation and part–whole relationships. For example, think about a doctor's office that has decided to create health care teams that include doctors, nurses, and administrative personnel. As patients enter the office, they are assigned to a health care team, which cares for their needs during their visits. We could include this new knowledge in Figure 5‐7 by adding two new classes (Administrative Personnel and Health Team) and aggregation relationships from the Doctor, the Nurse, and the new Administrative Personnel classes to the new Health Team class. A diamond is placed nearest the class representing the aggregation (health care team), and lines are drawn from the diamond to connect the classes that serve as its parts (doctors, nurses, and administrative personnel). Typically, you can identify these kinds of associations when you need to use words like “is a part of” or “is made up of” to describe the relationship. However, from a UML perspective, there are two types of aggregation associations: aggregation and composition (see Figure 5‐8).

- **Aggregation** is used to portray logical a‐part‐of relationships and is depicted on a UML class diagram by a hollow or white diamond. For example, in Figure 5‐13 three logical aggregations are shown. Logical implies that it is possible for a part to be associated with multiple wholes or that is relatively simple for the part to be removed from the whole. For example, an instance of the Employee class IsPartOf an instance of at least one instance of the Department class, an instance of the Wheel class IsPartOf an instance of the Vehicle class, and an instance of the Desk class IsPartOf an instance of the Office class. Obviously, in many cases an employee can be associated with more than one department, and it is relatively easy to remove a wheel from a vehicle or move a desk from an office.

![image](https://user-images.githubusercontent.com/73081144/177245101-5a4e4d89-5fe8-4bf0-acc9-287730607c47.png)

- **Composition** is used to portray a physical part of relationships and is shown by a black diamond. Physical implies that the part can be associated with only a single whole. For example in Figure 5‐14, three physical compositions are illustrated: an instance of a door can be a part of only a single instance of a car, an instance of a room can be a part of an instance only of a single building, and an instance of a button can be a part of only a single mouse. However, in many cases, the distinction that you can achieve by including aggregation (white diamonds) and composition (black diamonds) in a class diagram might not be worth the price of adding additional graphical notation for the client to learn. Therefore, many UML experts view the inclusion of aggregation and composition notation to the UML class diagram as simply “syntactic sugar” and not necessary because the same information can always be portrayed by simply using the correct multiplicities with the association syntax.

![image](https://user-images.githubusercontent.com/73081144/177245157-394fc339-7f3f-456a-8baf-5fb4450ff161.png)

## Simplifying Class Diagrams

When a class diagram is fully populated with all the classes and relationships for a real‐world system, the class diagram can become very difficult to interpret (i.e., can be very complex). For example, a typical real‐world system could have hundreds of classes. Therefore, it is sometimes necessary to simplify the diagram. One way to simplify the class diagram is to show only concrete classes.15 However, depending on the number of associations that are connected to abstract classes—and thus inherited down to the concrete classes—this particular suggestion could make the diagram more difficult to comprehend.

A second way to simplify the class diagram is through the use of a **view** mechanism. Views were developed originally with relational database management systems to show only a subset of the information contained in the database. In this case, the view would be a useful subset of the class diagram, such as a use‐case view that shows only the classes and relationships relevant to a particular use case. A second view could be to show only a particular type of relationship: aggregation, association, or generalization. A third type of view is to restrict the information shown with each class, for example, show only the name of the class, the name and attributes, or the name and operations. These view mechanisms can be combined to further simplify the diagram.

A third approach to simplifying a class diagram is through the use of **packages** (i.e., logical groups of classes). To make the diagrams easier to read and keep the models at a reasonable level of complexity, the classes can be grouped together into packages. Packages are general constructs that can be applied to any of the elements in UML models. In Chapter 4, we introduced the package idea to simplify use‐case diagrams. In the case of class diagrams, it is simple to sort the classes into groups based on the relationships that they share.

## Object Diagrams

Although class diagrams are necessary to document the structure of the classes, a second type of static structure diagram, called an object diagram, can be useful in revealing additional information. An object diagram is essentially an instantiation of all or part of a class diagram. Instantiation means to create an instance of the class with a set of appropriate attribute values.

Object diagrams can be very useful when trying to uncover details of a class. Generally speaking, it is easier to think in terms of concrete objects (instances) rather than abstractions of objects (classes). For example, in Figure 5‐15, a portion of the class diagram in Figure 5‐7 has been copied and instantiated. The top part of the figure simply is a copy of a small view of the overall class diagram. The lower portion is the object diagram that instantiates that subset of classes. By reviewing the actual instances involved, John Doe, Appt1, Symptom1, and Dr. Smith, we may discover additional relevant attributes, relationships, and/or operations or possibly misplaced attributes, relationships, and/or operations. For example, an appointment has a reason attribute. Upon closer examination, the reason attribute might have been better modeled as an association with the Symptom class. Currently, the Symptom class is associated with the Patient class. After reviewing the object diagram, this seems to be in error. Therefore, we should modify the class diagram to reflect this new understanding of the problem.

![image](https://user-images.githubusercontent.com/73081144/177245831-f7326720-cc63-466e-a9a3-01b20a04b537.png)
