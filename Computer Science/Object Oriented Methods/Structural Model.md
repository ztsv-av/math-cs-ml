# Structural Model

A structural model is a formal way of representing the objects that are used and created by a business system. The structural model describes the objects necessary to support the business processes modeled by the use cases. It illustrates people, places, or things about which information is captured and how they are related to one another. The structural model is drawn using an iterative process in which the model becomes more detailed and less conceptual over time. In analysis, analysts draw a conceptual model, which shows the logical organization of the objects without indicating how the objects are stored, created, or manipulated. Because this model is free from any implementation or technical details, the analysts can focus more easily on matching the model to the real business requirements of the system.

In design, analysts evolve the conceptual structural model into a design model that reflects how the objects will be organized in databases and software. At this point, the model is checked for redundancy, and the analysts investigate ways to make the objects easy to retrieve.

One of the primary purposes of the structural model is to create a vocabulary that can be used by the analyst and the users. Structural models represent the things, ideas, or concepts contained in the domain of the problem. They also allow the representation of the relationships among the things, ideas, or concepts. By creating a structural model of the problem domain, the analyst creates the vocabulary necessary for the analyst and users to communicate effectively.

It is important to remember that at this stage of development, the structural model does not represent software components or classes in an object‐oriented programming language, even though the structural model does contain analysis classes, attributes, operations, and the relationships among the analysis classes. The refinement of these initial classes into programming‐level objects comes later. Nonetheless, the structural model at this point should represent the responsibilities of each class and the collaborations among the classes. Typically, structural models are depicted using CRC cards, class diagrams, and object diagrams.

## Classes, Attributes, and Operations

A **class** is a general template that we use to create specific instances, or objects, in the problem domain. All objects of a given class are identical in structure and behavior but contain different data in their attributes. There are two general kinds of classes of interest during analysis: **concrete** and **abstract**. Normally, when an analyst describes the application domain classes, he or she is referring to **concrete** classes; that is, concrete classes are used to create objects. **Abstract** classes do not actually exist in the real world; they are simply useful abstractions. For example, from an employee class and a customer class, we may identify a generalization of the two classes and name the abstract class person. We might not actually instantiate the person class in the system itself, instead creating and using only employees and customers.1

A second classification of classes is the type of real‐world thing that a class represents. There are domain classes, user‐interface classes, data structure classes, file structure classes, operating environment classes, document classes, and various types of multimedia classes. At this point in the development of our evolving system, we are interested only in domain classes. **Domain classes** represent objects in the problem domain, that is, they are used to represent objects that meet the functional, not nonfunctional requirements. Later in design and implementation, the other types of classes, which represent the nonfunctional requirements, become relevant.

An **attribute** of an analysis class represents a piece of information that is relevant to the description of the class within the application domain of the problem being investigated. An attribute contains information the analyst or user feels the system should keep track of. For example, a possible relevant attribute of an employee class is employee name, whereas one that might not be as relevant is hair color. Both describe something about an employee, but hair color is probably not all that useful for most business applications. Only attributes that are important to the task should be included in the class. Finally, only attributes that are primitive or atomic types (i.e., integers, strings, doubles, date, time, Boolean, etc.) should be added. Most complex or compound attributes are really placeholders for relationships between classes. Therefore, they should be modeled as relationships, not as attributes (see the next section).

The behavior of an analysis class is defined in an **operation** or service. During design, the analyst will convert the operations to **methods**. However, because methods are more related to implementation, at this point in the development we use the term operation to describe the actions to which the **instances** of the class are capable of responding. Like attributes, only problem domain–specific operations that are relevant to the functional requirements should be considered.

## Relationships

There are many different types of relationships that can be defined, but all can be classified into three basic categories of data abstraction mechanisms: generalization relationships, aggregation relationships, and association relationships. These data‐abstraction mechanisms allow the analyst to focus on the important dimensions while ignoring nonessential dimensions. As with attributes, the analyst must be careful to include only relationships that address the functional requirements.

### Generalization Relationships

The generalization relationship is the same relationship as the class inclusion semantic relationship that was used in domain and taxonomic analysis (see Chapter 3). The generalization abstraction enables the analyst to create classes that inherit attributes and operations of other classes. The analyst creates a superclass that contains basic attributes and operations that will be used in several subclasses. The subclasses inherit the attributes and operations of their superclass and can also contain attributes and operations that are unique just to them. For example, a customer class and an employee class can be generalized into a person class by extracting the attributes and operations both have in common and placing them into the new superclass, person. In this way, the analyst can reduce the redundancy in the class definitions so that the common elements are defined once and then reused in the subclasses. Generalization is represented with the a‐kind‐of relationship, so that we say that an employee is a‐kind‐of person.2

The analyst also can use the opposite of generalization. Specialization uncovers additional classes by allowing new subclasses to be created from an existing class. For example, an employee class can be specialized into a secretary class and an engineer class. Furthermore, generalization relationships between classes can be combined to form generalization hierarchies. Based on the previous examples, a secretary class and an engineer class can be subclasses of an employee class, which in turn could be a subclass of a person class. This would be read as a secretary and an engineer are a‐kind‐of employee and a customer and an employee are a‐kind‐of person.

The generalization data abstraction is a very powerful mechanism that encourages the analyst to focus on the properties that make each class unique by allowing the similarities to be factored into superclasses. However, to ensure that the semantics of the subclasses are maintained, the analyst should apply the principle of substitutability. By this we mean that the subclass should be capable of substituting for the superclass anywhere that uses the super‐class (e.g., anywhere we use the employee superclass, we could also logically use its secretary subclass). By focusing on the a‐kind‐of interpretation of the generalization relationship, the principle of substitutability is supported.

### Aggregation Relationships

The aggregation relationship is the same relationship as the part whole semantic relationship that was used in domain and taxonomic analysis (see Chapter 3). Generally speaking, all aggregation relationships relate parts to wholes or assemblies. For our purposes, we use the a‐part‐of or has‐parts semantic relationship to represent the aggregation abstraction. For example, a door is a‐part‐of a car, an employee is a‐part‐of a department, or a department is a‐part‐of an organization. Like the generalization relationship, aggregation relationships can be combined into aggregation hierarchies. For example, a piston is a‐part‐of an engine, and an engine is a‐part‐of a car.

Aggregation relationships are bidirectional. The flip side of aggregation is decomposition. The analyst can use decomposition to uncover parts of a class that should be modeled separately. For example, if a door and an engine are a‐part‐of a car, then a car has‐parts door and engine. The analyst can bounce around between the various parts to uncover new parts. For example, the analyst can ask, What other parts are there to a car? or To which other assemblies can a door belong?

### Association Relationships

There are other types of relationships that do not fit neatly into a generalization (a‐kind‐of) or aggregation (a‐part‐of) framework. Technically speaking, these relationships are usually a weaker form of the aggregation relationship. For example, a patient schedules an appointment. It could be argued that a patient is a‐part‐of an appointment. However, there is a clear semantic difference between this type of relationship and one that models the relationship between doors and cars or even workers and unions. Thus, they are simply considered to be associations between instances of classes.


## Object Identification Techniques

- Textual Analysis: The analyst performs textual analysis by reviewing the use‐case diagrams and examining the text in the use‐case descriptions to identify potential objects, attributes, operations, and relationships. The nouns in the use case suggest candidate classes, and the verbs suggest possible operations. Figure 5‐1 presents a summary of useful guidelines. In addition to these guidelines, the text analysis approaches described in Chapter 3, sentence diagramming and domain, taxonomic, componential, and theme analysis, are helpful. The textual analysis of use‐case descriptions has been criticized as being too simple, but because its primary purpose is to create an initial rough‐cut structural model, its simplicity is a major advantage. For example, if we applied these rules to the Make Old Patient Appt use case described in Chapter 4 (see Figure 5‐2), we can easily identify potential objects for an old patient, doctor, appointment, patient, office, receptionist, name, address, patient information, payment, date, and time. We also can easily identify potential operations that can be associated with the identified objects. For example, patient contacts office, makes a new appointment, cancels an existing appointment, changes an existing appointment, matches requested appointment times and dates with requested times and dates, and finds current appointment.

- Brainstorming: Brainstorming is a discovery technique that has been used successfully in identifying candidate classes. Essentially, in this context, brainstorming is a process that a set of individuals sitting around a table suggest candidate classes that could be useful for the problem under consideration, that is, that meet the functional requirements. Typically, a brainstorming session is kicked off by a facilitator who asks the set of individuals to address a specific question or a statement that frames the session. 

![image](https://user-images.githubusercontent.com/73081144/177238771-bd29b714-31f9-4346-9ee1-619bd8a4222c.png)

- Patterns: The idea of using patterns is a relatively new area in object‐oriented systems development.5 There have been many definitions of exactly what a pattern is. From our perspective, a pattern is simply a useful group of collaborating classes that provide a solution to a commonly occurring problem. Because patterns provide a solution to commonly occurring problems, they are reusable. An architect, Christopher Alexander, has inspired much of the work associated with using patterns in object‐oriented systems development. According to Alexander and his colleagues,6 it is possible to make very sophisticated buildings by stringing together commonly found patterns, rather than creating entirely new concepts and designs. In a similar manner, it is possible to put together commonly found object‐oriented patterns to form elegant object‐oriented information systems. For example, many business transactions involve the same types of objects and interactions. Virtually all transactions would require a transaction class, a transaction line item class, an item class, a location class, and a participant class. By reusing these existing patterns of classes, we can more quickly and more completely define the system than if we start with a blank piece of paper.

![image](https://user-images.githubusercontent.com/73081144/177239185-8423df51-f838-46fe-9245-665fad0ec69c.png)
![image](https://user-images.githubusercontent.com/73081144/177239221-e949bfca-c999-4170-aac2-e8332047a493.png)

In this manner, using patterns from different sources enables the development team to leverage knowledge beyond that of the immediate team members and allows the team to develop more complete and robust models of the problem domain. For example, in the case of the appointment problem, we can look at the objects previously identified through textual analysis and brainstorming and see if it makes sense to map any of them into any predefined reusable patterns. In this specific case, we can look at an appointment as a type of transaction in which a doctor's office participates. By looking at an appointment as a type of transaction, we can apply the pattern we created in Figure 5‐4 and discover a set of previously unidentified objects, such as Place, Patient as a type of Participant, and Transaction Line Items that are associated with different types of Items (Goods and/or Services). Discovering these specific additional objects could be useful in developing the billing side of the appointment system. Even though these additional objects could be applicable, they were not uncovered using the other techniques.


## Structual Model Creation Process Using CRC Cards and Class Diagrams

Creating a structural model is an incremental and iterative process whereby the analyst makes a rough cut of the model and then refines it over time. Structural models can become quite complex—in fact, there are systems that have hundreds of classes. It is important to remember that CRC cards and class diagrams can be used to describe both the as‐is and to‐be structural models of the evolving system, but they are most often used for the to‐be model. There are many different ways to identify a set of candidate objects and to create CRC cards and class diagrams. Today most object identification begins with the use cases identified for the problem (see Chapter 4). In this section, we describe a use‐case–driven process that can be used to create the structural model of a problem domain.

1. **Create CRC Cards**
We could begin creating the structural model with a class diagram instead of CRC cards. However, owing to the low‐tech nature and the ease of role‐playing use‐case scenarios with CRC cards, we prefer to create the CRC cards first and then transfer the information from the CRC cards into a class diagram later. As a result, the first step of our recommended process is to create CRC cards. Performing textual analysis on the use‐case descriptions does this. If you recall, the normal flow of events, subflows, and alternative/exceptional flows of the use‐case description were written in a special form called Subject–Verb–Direct object–Preposition–Indirect object (SVDPI). By writing the use‐case events in this form, it is easier to use the guidelines for textual analysis in Figure 5‐1 and the text analysis approaches described in Chapter 3 to identify the objects. Reviewing the primary actors, stakeholders and interests, and brief descriptions of each use case allows additional candidate classes to be identified. It is useful to go back and review the original requirements to look for information that was not included in the text of the use cases. Record all the uncovered information for each candidate object on a CRC card.
2. **Review CRC Cards**
The second step is to review the CRC cards to determine if additional candidate classes, attributes, operations, and relationships are missing. In conjunction with this review, using the brainstorming approach described earlier can aid the team in identifying missing classes, attributes, operations, and relationships. For example, the team could start a brainstorming session with a set of questions such as follows:
- What are the tangible things associated with the problem?
- What are the roles played by the people in the problem domain?
- What incidents and interactions take place in the problem domain?
As you can readily see, by beginning with the use‐case descriptions, many of these questions already have partial answers. For example, the primary actors and stakeholders are the roles that are played by the people in the problem domain. However, it is possible to uncover additional roles not thought of previously. This obviously would cause the use‐case descriptions, and possibly the use‐case diagram, to be modified and possibly expanded. As in the previous step, be sure to record all the uncovered information onto the CRC cards. This includes any modifications uncovered for any previously identified candidate classes and any information regarding any new candidate classes identified.
3. **Role‐Play the CRC Cards**
The third step is to role‐play each use‐case scenario using the CRC cards. Each CRC card should be assigned to an individual who will perform the operations for the class on the CRC card. As the performers act out their roles, the system tends to break down. When this occurs, additional classes, attributes, operations, or relationships will be identified. Again, as in the previous steps, any time any new information is discovered, new CRC cards are created or modifications to existing CRC cards are made.
4. **Create Class Diagram**
The fourth step is to create the class diagram based on the CRC cards. Information contained on the CRC cards is transferred to the class diagrams. The responsibilities are transferred as operations; the attributes are drawn as attributes; and the relationships are drawn as generalization, aggregation, or association relationships. However, the class diagram also requires that the visibility of the attributes and operations be known. As a general rule, attributes are private and operations are public. Therefore, unless the analyst has a good reason to change the default visibility of these properties, then the defaults should be accepted. Finally, the analyst should examine the model for additional opportunities to use aggregation or generalization relationships. These types of relationships can simplify the individual class descriptions. As in the previous steps, all changes must be recorded on the CRC cards.
5. **Review Class Diagram**
The fifth step is to review the structural model for missing and/or unnecessary classes, attributes, operations, and relationships. Until this step, the focus of the process has been on adding information to the evolving model. At this point, the focus begins to switch from simply adding information to also challenging the reasons for including the information contained in the model. One very useful approach here is to play devil's advocate, where a team member, just for the sake of being a pain in the neck, challenges the reasoning for including all aspects of the model.
6. **Incorporate Patterns**
The sixth step is to incorporate useful patterns into the evolving structural model. A useful pattern is one that would allow the analyst to more fully describe the underlying domain of the problem being investigated. Looking at the collection of patterns available (Figure 5‐5) and comparing the classes contained in the patterns with those in the evolving class diagram enable this. After identifying the useful patterns, the analyst incorporates the identified patterns into the class diagram and modifies the affected CRC cards. This includes adding and removing classes, attributes, operations, and/or relationships.
7. **Review the Model**
The seventh and final step is to validate the structural model, including both the CRC cards and the class diagram. We discuss this content in the next section of the chapter and in Chapter 6.


## Library Example

### Overview Description of the Library Book Collection Management System
*The functional requirements for an automated university library circulation system include the need to support searching, borrowing, and book‐maintenance activities. The system should support searching by title, author, keywords, and ISBN. If the book of interest is currently checked out, a valid borrower should be allowed to request the book to be returned. Once the book has been checked back in, the borrower requesting the book should be notified of the book's availability. The borrowing activities are built around checking books out and returning books by borrowers. There are three types of borrowers: students, faculty or staff, and guests. Regardless of the type of borrower, the borrower must have a valid ID card. If the borrower is a student, having the system check with the registrar's office to validate the ID card. If the borrower is a faculty or staff member, having the system check with the personnel office to validate the ID card. If the borrower is a guest, the ID card is checked against the library's own system. If the ID card is valid, the system must also check to determine whether the borrower has any overdue books or unpaid fines. If the ID card is invalid, the borrower has overdue books, or the borrower has unpaid fines, the system must reject the borrower's request to check out a book, otherwise the borrower's request should be honored. If a book is checked out, the system must update the library's collection to reflect the book's new status. The book‐maintenance activities deal with adding and removing books from the library's book collection. This requires a library manager to both logically and physically add and remove the book. Books being purchased by the library or books being returned in a damaged state typically cause these activities. If a book is determined to be damaged when it is returned and it needs to be removed from the collection, the last borrower will be assessed a fine. However, if the book can be repaired, depending on the cost of the repair, the borrower might not be assessed a fine. Every Monday, the library sends a reminder to borrowers who have overdue books. If a book is overdue more than two weeks, the borrower is assessed a fine. Depending on how long the book remains overdue, the borrower can be assessed additional fines every Monday.*

The first step is to create the CRC cards that represent the classes in the structural model. In the previous chapter, we used the Library Book Collection Management System example to describe the process of creating the functional models (use‐case and activity diagrams and use‐case descriptions). In this chapter, we follow the same familiar example. Because we are following a use‐case‐driven approach to object‐oriented systems development, we first review the events described in the use‐case descriptions (see Figure 5‐18).

Next, we perform textual analysis on the events by applying the textual analysis rules described in Figure 5‐1. In this case, we can quickly identify the need to include classes for Borrower, Books, Librarian, Check Out Desk, ID Card, Student Borrower, Faculty/Staff Borrower, Guest Borrower, Registrar's Database, Personnel Database, Library's Guest Database, Overdue Books, Fines, and Book Request. We also can easily identify operations to “check the validity” of a book request, to “check out” the books, and to “reject” a book request. Furthermore, the events suggest a “brings” relationship between Borrower and Books and a “provides” relationship between Borrower and Librarian. This step also suggests that we should review the overview section of the use‐case description (see Figure 5‐19). In this case, the only additional information gleaned from the use‐case description is the possible inclusion of classes for Personnel Office and Registrar's Office. This same process would also be completed for the remaining use cases contained in the functional model: Process Overdue Books, Maintain Book Collection, Search Collection, and Return Books (see Figure 4‐6). Since we did not discuss these use cases in the previous chapter, we will review the problem description as a basis for beginning the next step.

![image](https://user-images.githubusercontent.com/73081144/177252676-6ca9aa91-cac3-41c7-a35c-45e9a1f0f50f.png)

The second step is to review the CRC cards to determine if there is any information missing. In the case of the library system, because we only used the Borrow Books use‐case description, some information is obviously missing. By reviewing Figure 5‐20, we see that we need to include the ability to search the book collection by title, author, keywords, and ISBN. This obviously implies a Book Collection class with four different search operations: Search By Title, Search By Author, Search By Keywords, and Search By ISBN. Interestingly, the description also implies either a set of subclasses or states for the Book class: Checked Out, Overdue, Requested, Available, and Damaged. We will return to the issue of states versus subclasses in the next chapter. The description implies many additional operations, including Returning Books, Requesting Books, Adding Books, Removing Books, Repairing Books, Fining Borrowers, and Emailing Reminders.

Next, we should use our own library experience to brainstorm potential additional classes, attributes, operations, and relationships that could be useful to include in the Library Book Collection Management System. In our library, there is also the need to Retrieve Books From Storage, Move Books to Storage, Request Books from the Interlibrary Loan System, Return Books to the Interlibrary Loan System, and Deal with E‐Books. You also could include classes for Journals, DVDs, and other media. As you can see, many classes, attributes, operations, and relationships can be identified.

The third step, role‐playing the CRC cards, requires us to apply the three role‐playing steps described earlier:

- Review use cases
- Identify relevant actors and objects
- Role‐play scenarios
  
For our purposes, we will use the Borrow Books use case to demonstrate. The relevant actors include Student Borrowers, Faculty/Staff Borrowers, Guest Borrowers, Librarians, Personnel Office, and Registrar's Office. These can be easily gleaned from the overview section of the use‐case description (see Figure 5‐19) and the use‐case diagram (see Figure 4‐6). The relevant objects seem to include Books, Borrower, and ID Card. Finally, to role‐play the scenarios, we need to assign the roles to the different members of the team and try to perform each of the paths through the events of the use‐case (see Figure 5‐18). Based on the Events of the use case and the use case's activity diagram (see Figure 5‐21):

![image](https://user-images.githubusercontent.com/73081144/177253731-184220f4-d772-400e-8ccb-7e84fa8c47e5.png)

...we can quickly identify nine scenarios, three for each type of Borrower (Student, Faculty/Staff, and Guest): Valid ID and No Overdue Books and No Fines, Valid ID only, and No Valid ID. When role‐playing these scenarios, one question arises: What happens to the books that are requested when the request is rejected? Based on the current functional and structural models, the books are left sitting on the check out desk. That doesn't quite seem right. In reality, the books are reshelved. In fact, the notion of reshelving books is also relevant to when books are checked back in or after books have been repaired. Furthermore, the idea of adding books to the collection should also include the operation of shelving the books. As you should readily see, building structural models will also help uncover behavior that was omitted when building the functional models. Remember, object‐oriented systems development is not only use‐case driven but also is incremental and iterative.

The fourth step is to put everything together and to draw the class diagram. Figure 5‐22 represents the first cut at drawing the class diagram for the Library Book Collection Management System. The classes identified in the previous steps have been linked with other classes via association, aggregation, and generalization relationships. For simplicity purposes, we only show the classes and their relationships, not their attributes, operations, or even the multiplicities on the association relationships.

![image](https://user-images.githubusercontent.com/73081144/177253789-1876a7d9-d11b-48c0-96a2-47fba1b29712.png)

The fifth step is to carefully review what has been created. Not only should you look for any missing classes, attributes, operations, and/or relationships, but you should also challenge every aspect of the current model. Specifically, are there classes, attributes, operations, and/or relationships that should be removed from the model? If so, there may be classes on the diagram that should have been modeled as attributes. For example, the Student, Fac/Staff, and Guest IDs should have been attributes with their respective classes. Furthermore, because this is a book collection management system, the inclusion of other media seems to be inappropriate. Finally, the Personnel Office and Registrar's Office are actually only actors in the system, not objects. Based on all of these deletions, a new version of the class diagram was drawn (see Figure 5‐23). This diagram is much simpler and easier to understand.

![image](https://user-images.githubusercontent.com/73081144/177253824-2e847a47-ddd7-4d71-9932-86f3ea684888.png)

The sixth step, incorporating useful patterns, enables us to take advantage of knowledge that was developed elsewhere. In this case, the pattern used in the library problem includes too many ideas that are not relevant to the current problem. However, by looking back to Figure 5‐3, we see that one of the original patterns (the Place, Transaction, Participant, Transaction Line Item, and Item pattern—see the top left of the figure) is relevant. We incorporate that pattern into the class diagram by replacing Place by Check Out Desk, Participant by Borrower, Transaction by Check Out Trans, and Item by Book (Figure 5‐24). Technically speaking, each of these replacements is simply a pattern customized to the problem at hand. We also then add the Transaction Line Item class that we had missed in the original structural model.

![image](https://user-images.githubusercontent.com/73081144/177253915-52ff1bb5-efa3-48bd-8a7e-ac57205e5bc1.png)

The seventh step is to review the current state of the structural model. Needless to say, the CRC card version and the class diagram version are no longer in agreement with each other. 
