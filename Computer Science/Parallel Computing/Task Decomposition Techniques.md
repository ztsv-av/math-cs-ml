# Task Decomposition Techniques

One of the most critical steps in parallel computing is decomposition, where computations are split into several tasks to allow for parallel execution based on a task-dependency graph.

## Recursive Decomposition

Recursive decomposition employs a divide-and-conquer approach, wherein a problem is solved by first breaking it up into a set of independent tasks or subproblems. Each task is then solved recursively in the same fashion as the main problem. This approach results in concurrency, which helps solve each tasks simultaneously.

One of the most popular examples of recursive decomposition is quicksort, which is a sorting algorithm that is primarily based on partitioning. Given an array and an element x used as a pivot, quicksort involves putting the pivot element in its correct position in the sorted array, putting all of the smaller numbers before the pivot, and putting all of the larger numbers after the pivot

## Data decomposition

Data decomposition is another method that is used to build parallelism. This decomposition is best used when multiple instances of the same problem work on a specific data subset. In this method, the data set is a shared resource, and tasks cannot concurrently change the same data because they would be protected through the implementation of a critical section.

Imagine that you would like to multiply a 2 Ã— 2 matrix by a 4. In a traditional sequential process, you would perform each multiplication sequentially (one after the other) to ultimately generate the final result.

Although this approach is effective, it can be error-prone and time-consuming. Using data decomposition, the matrix is broken up into pieces, and each piece can be associated with a worker process which each process working in parallel. The results generated by each worker process are combined and correlated to produce the end result. In the following example diagram, each of the values are multiplied separately by a worker process to produce the new matrix:

![image](https://user-images.githubusercontent.com/73081144/172282583-c6c217c0-932e-4398-8a0f-aeb42772e2d2.png)

## Exploratory decomposition

In exploratory decomposition, the search space is broken up into smaller parts, and each part is searched concurrently until the desired solution is found. Exploratory decomposition may look similar to data decomposition, but in the latter's case, each task is separate and performs useful computations toward the final solution. Exploratory decomposition tasks may not be completely finished and may be terminated as soon as the final solution is found.

## Speculative decomposition

Speculative decomposition is primarily used when a program may take one or more possibly significant branches in the task-dependency graph based on the output of the results from previous computations. In other words, the output of each task can decide the next computation, and other tasks can concurrently determine the next step. This is similar to the switch control structure in Java or C++, where the value of a variable can determine which branch is executed. In some instances, multiple branches may be executed sequentially.

## Hybrid decomposition

In hybrid decomposition, multiple decomposition techniques can be combined, allowing different decomposition techniques to be used in different stages of the computation process. For example, when attempting to find the minimum of a set of numbers, data decomposition can be used to break up the set of numbers (Grama et al., 2003). Recursive decomposition can then be used to partition the input in equal parts, with each task computing the minimum of the sequence assigned to it. The final solution is found by identifying the minimum of the intermediate results using recursive decomposition, as demonstrated in the following image:

![image](https://user-images.githubusercontent.com/73081144/172282935-1a87353b-9997-4115-83b3-90f752ab6bf9.png)

In a hybrid decomposition, decompositions may be applied hierarchically to match the processing resources in the best possible way.
